import os
import logging
import re
from typing import Optional, Any
from datetime import datetime

class NotesSaver:
    """
    Notes saver for converting organized content to Markdown format for Obsidian.
    """

    def __init__(self, output_directory: str = "data/notes"):
        """
        Initialize the notes saver.

        Args:
            output_directory (str): Directory to save the Markdown notes
        """
        self.output_directory: str = output_directory
        self.logger: logging.Logger = logging.getLogger(__name__)

        # Create output directory if it doesn't exist
        os.makedirs(self.output_directory, exist_ok=True)

    def save_organized_content(self, organized_content: dict[str, Any], batch_name: Optional[str] = None) -> str:
        """
        Save organized content as a Markdown file for Obsidian.

        Args:
            organized_content (dict): Organized content from AI processor
            batch_name (Optional[str], optional): Name for the batch of content

        Returns:
            str: Path to the saved Markdown file
        """
        try:
            # Generate filename with timestamp
            if batch_name is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                batch_name = f"sat_act_notes_{timestamp}"

            filename = f"{batch_name}.md"
            filepath = os.path.join(self.output_directory, filename)

            # Generate Markdown content
            markdown_content = self._generate_markdown(organized_content)

            # Write to file
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(markdown_content)

            self.logger.info(f"Successfully saved organized content to {filepath}")
            return filepath

        except Exception as e:
            self.logger.error(f"Error saving organized content: {str(e)}")
            raise

    def _generate_markdown(self, organized_content: dict[str, Any]) -> str:
        """
        Generate Markdown content from organized content.

        Args:
            organized_content (dict): Organized content from AI processor

        Returns:
            str: Generated Markdown content
        """
        lines = []

        # Add title
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        lines.append(f"# SAT/ACT Study Materials - {timestamp}")
        lines.append("")

        # Add summary
        summary = organized_content.get("summary", "No summary provided")
        lines.append(f"## Summary")
        lines.append(summary)
        lines.append("")

        # Add relationships
        relationships = organized_content.get("relationships", "No relationships identified")
        lines.append(f"## Content Relationships")
        lines.append(relationships)
        lines.append("")

        # Add notes section
        notes = organized_content.get("notes", [])
        if notes:
            lines.append("## Notes")
            for i, note in enumerate(notes, 1):
                lines.append(f"### Note {i}")
                content = note.get("content", "No content")
                lines.append(content)

                # Add related wrong questions if any
                related_questions = note.get("related_wrong_questions", [])
                if related_questions:
                    related_list = ", ".join([f"Question {q+1}" for q in related_questions])
                    lines.append(f"**Related Wrong Questions:** {related_list}")

                lines.append("")

        # Add wrong questions section
        wrong_questions = organized_content.get("wrong_questions", [])
        if wrong_questions:
            lines.append("## Wrong Questions")
            for i, question in enumerate(wrong_questions, 1):
                lines.append(f"### Question {i}")
                content = question.get("content", "No content")
                lines.append(content)

                # Add related notes if any
                related_notes = question.get("related_notes", [])
                if related_notes:
                    related_list = ", ".join([f"Note {n+1}" for n in related_notes])
                    lines.append(f"**Related Notes:** {related_list}")

                # Add mistake explanation
                mistake = question.get("mistake_explanation", "")
                if mistake:
                    lines.append(f"**Mistake Explanation:** {mistake}")

                # Add correct approach
                approach = question.get("correct_approach", "")
                if approach:
                    lines.append(f"**Correct Approach:** {approach}")

                lines.append("")

        # Add metadata
        lines.append("---")
        lines.append(f"**Generated on:** {timestamp}")
        lines.append(f"**Total Notes:** {len(notes)}")
        lines.append(f"**Total Wrong Questions:** {len(wrong_questions)}")

        return "\n".join(lines)

    def save_classification_result(self, ocr_text: str, classification_result: dict[str, Any],
                                 image_filename: Optional[str] = None) -> str:
        """
        Save individual classification result as a Markdown file.

        Args:
            ocr_text (str): Original OCR extracted text
            classification_result (dict): Classification result from AI processor
            image_filename (Optional[str], optional): Original image filename

        Returns:
            str: Path to the saved Markdown file
        """
        try:
            # Generate filename
            if image_filename:
                base_name = os.path.splitext(image_filename)[0]
                filename = f"classification_{base_name}.md"
            else:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"classification_{timestamp}.md"

            filepath = os.path.join(self.output_directory, filename)

            # Generate Markdown content
            lines = []

            # Add title
            lines.append(f"# Classification Result - {filename}")
            lines.append("")

            # Add classification info
            classification = classification_result.get("classification", "unknown")
            confidence = classification_result.get("confidence", 0.0)
            reasoning = classification_result.get("reasoning", "No reasoning provided")

            lines.append(f"**Type:** {classification}")
            lines.append(f"**Confidence:** {confidence:.2f}")
            lines.append(f"**Reasoning:** {reasoning}")
            lines.append("")

            # Add original OCR text
            lines.append("## Original OCR Text")
            lines.append("```")
            lines.append(ocr_text)
            lines.append("```")
            lines.append("")

            # Add metadata
            timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            lines.append("---")
            lines.append(f"**Classified on:** {timestamp}")
            if image_filename:
                lines.append(f"**Source Image:** {image_filename}")

            markdown_content = "\n".join(lines)

            # Write to file
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(markdown_content)

            self.logger.info(f"Successfully saved classification result to {filepath}")
            return filepath

        except Exception as e:
            self.logger.error(f"Error saving classification result: {str(e)}")
            raise

def update_existing_note(self, existing_note_path: str, new_content: dict[str, Any]) -> str:
        """
        Update an existing note with new content, merging related information.

        Args:
            existing_note_path (str): Path to the existing note file
            new_content (dict): New organized content to merge

        Returns:
            str: Path to the updated Markdown file
        """
        try:
            # Read existing note content
            if os.path.exists(existing_note_path):
                with open(existing_note_path, 'r', encoding='utf-8') as f:
                    existing_content = f.read()
            else:
                # If file doesn't exist, create a new one
                return self.save_organized_content(new_content, os.path.splitext(os.path.basename(existing_note_path))[0])

            # Parse existing content to extract sections
            existing_sections = self._parse_existing_note(existing_content)
            
            # Merge new content with existing content
            merged_content = self._merge_content(existing_sections, new_content)
            
            # Generate updated Markdown content
            updated_markdown = self._generate_markdown(merged_content)
            
            # Write updated content to file
            with open(existing_note_path, 'w', encoding='utf-8') as f:
                f.write(updated_markdown)
                
            self.logger.info(f"Successfully updated existing note at {existing_note_path}")
            return existing_note_path
            
        except Exception as e:
            self.logger.error(f"Error updating existing note: {str(e)}")
            raise

def _parse_existing_note(self, content: str) -> dict[str, Any]:
        """
        Parse an existing note to extract its sections.

        Args:
            content (str): The existing note content

        Returns:
            dict: Parsed sections of the note
        """
        sections = {
            "title": "",
            "summary": "",
            "relationships": "",
            "notes": [],
            "wrong_questions": [],
            "metadata": {}
        }
        
        # Extract title (first line starting with #)
        title_match = re.search(r'^# (.+)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
, content, re.MULTILINE)
, content, re.MULTILINE)
        if title_match:
            sections["title"] = title_match.group(1)
            
        # Extract summary (text under ## Summary)
        summary_match = re.search(r'## Summary\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if summary_match:
            sections["summary"] = summary_match.group(1).strip()
            
        # Extract relationships (text under ## Content Relationships)
        relationships_match = re.search(r'## Content Relationships\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if relationships_match:
            sections["relationships"] = relationships_match.group(1).strip()
            
        # Extract notes (sections under ## Notes)
        notes_match = re.search(r'## Notes\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if notes_match:
            notes_content = notes_match.group(1)
            # Extract individual notes
            note_matches = re.findall(r'### Note \d+\s+(.+?)(?=\n### Note |\n## |\n---|\Z)', notes_content, re.DOTALL)
            sections["notes"] = [{"content": note.strip()} for note in note_matches]
            
        # Extract wrong questions (sections under ## Wrong Questions)
        questions_match = re.search(r'## Wrong Questions\s+(.+?)(?=\n## |\n---|\Z)', content, re.DOTALL)
        if questions_match:
            questions_content = questions_match.group(1)
            # Extract individual questions
            question_matches = re.findall(r'### Question \d+\s+(.+?)(?=\n### Question |\n## |\n---|\Z)', questions_content, re.DOTALL)
            sections["wrong_questions"] = [{"content": question.strip()} for question in question_matches]
            
        return sections
        
    def _merge_content(self, existing_sections: dict[str, Any], new_content: dict[str, Any]) -> dict[str, Any]:
        """
        Merge existing content with new content.

        Args:
            existing_sections (dict): Parsed existing content
            new_content (dict): New content to merge

        Returns:
            dict: Merged content
        """
        merged = {}
        
        # Merge summary
        existing_summary = existing_sections.get("summary", "")
        new_summary = new_content.get("summary", "")
        merged["summary"] = f"{existing_summary}\n\nUpdated: {new_summary}".strip() if existing_summary else new_summary
        
        # Merge relationships
        existing_relationships = existing_sections.get("relationships", "")
        new_relationships = new_content.get("relationships", "")
        merged["relationships"] = f"{existing_relationships}\n\n{new_relationships}".strip() if existing_relationships else new_relationships
        
        # Merge notes
        existing_notes = existing_sections.get("notes", [])
        new_notes = new_content.get("notes", [])
        merged["notes"] = existing_notes + new_notes
        
        # Merge wrong questions
        existing_questions = existing_sections.get("wrong_questions", [])
        new_questions = new_content.get("wrong_questions", [])
        merged["wrong_questions"] = existing_questions + new_questions
        
        return merged

    def find_related_notes(self, topic: str) -> list[str]:
        """
        Find existing notes related to a specific topic.

        Args:
            topic (str): Topic to search for

        Returns:
            list: List of paths to related notes
        """
        related_notes = []
        
        # Search for markdown files in the output directory
        for filename in os.listdir(self.output_directory):
            if filename.endswith('.md') and filename.startswith('sat_act_notes'):
                filepath = os.path.join(self.output_directory, filename)
                with open(filepath, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # Simple keyword matching - in a real implementation, you might use
                    # more sophisticated techniques like TF-IDF or embedding similarity
                    if topic.lower() in content.lower():
                        related_notes.append(filepath)
                        
        return related_notes

# Example usage
if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(level=logging.INFO)

    # Example organized content
    example_content = {
        "summary": "This batch contains 2 notes and 1 wrong question about quadratic equations.",
        "notes": [
            {
                "content": "The quadratic formula is x = (-b +/- sqrt(b^2 - 4ac)) / (2a) for equations of the form ax^2 + bx + c = 0.",
                "related_wrong_questions": [0]
            }
        ],
        "wrong_questions": [
            {
                "content": "Solve x^2 + 5x + 6 = 0. I tried factoring but got x = -2, -4 which is wrong.",
                "related_notes": [0],
                "mistake_explanation": "Incorrect factoring - the factors of 6 that add to 5 are 2 and 3, not 4 and 1.",
                "correct_approach": "Factor as (x + 2)(x + 3) = 0, giving solutions x = -2, -3."
            }
        ],
        "relationships": "The note on quadratic formula directly relates to the wrong question about solving quadratic equations."
    }

    # Initialize notes saver
    notes_saver = NotesSaver()

    # Save organized content
    try:
        filepath = notes_saver.save_organized_content(example_content, "quadratic_equations_example")
        print(f"Saved example content to: {filepath}")
    except Exception as e:
        print(f"Error saving example content: {e}")
